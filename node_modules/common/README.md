# Common API Clients

This repository contains wrapper libraries to abstract access to internal service APIs.

## Adding an API client

A service library has 3 components
- an API Client, which is used to convert function calls into outbound API HTTP Requests
- a service wrapper, which is used to actually shepherd values into the wrapper library, and which implements the injectable interface so that it can be used in ios.ts files
- Tests, because tests are important.

They also imply the existence of a "host" value in the config.  So for the LoansService, there is an implied `services.loans.host` configuration value, which if not found is defaulted to `https://loans:8080`

### Create the API Client

Api clients are auto generated based on swagger files.  So, for a given service, we will use the `swagger.yml` file from the `/docs/ folder in that service.

The conversion of a swagger file into an API client library is done automatically.  Most of ours were generated using `https://editor.swagger.io`

- Take the interface definition from the source repo of the service you are adding, and paste it into `editor.swagger.io`
- When it is rendered, go to Generate Client -> Typescript Node, which will download a Zip file.
- Take the file `api.ts` from the zip file, and copy the contents into a new file in `common/src/main/api_clients/{YourService}API.ts`.
- At the top of this file, add `/* tslint:disable */` to deal with the typing errors.

This file will also have a lot of lines that say

    throw new Error('some error message');

Which we want to replace with either

    return Promise.reject('some error mesage');

or

    return reject('some error message');


You may need to also ensure that the file complies.  If you run tests after getting it set up, and see an error that looks like `Cannot read property 'prototype' of undefined`, there is a chance that the model definitions in the auto generated API Client file are out of order.  Go in and make sure that nothing extends something which is defined after it.

ie.

    export class Hey extends Greeting {}
    export class Greeting {}

will probably fail

Also, make sure to go to the line where it says

    protected defaultHeaders: any = {};

and replace it with

    protected defaultHeaders: any = {
        accept: "application/json",
    };

You may need on a case by case basis to set the content type of various requests.  But this really assumes that the API returns JSON.  Someday we should really add these fixes to the actual library that is generating these files.

### Create the injectable service interface

We do not use these interfaces directly, instead we create an interface library with *very* similar methods.

Make a file in `src/main/services` which will create an injectable interface that can be used to call the methods.

Best case just refer to the examples like `loans.service.ts` to come up with a pattern.

Note: in the constructor you will have to choose your new config parameter which points to the url of the service.

Go through every method in the generated file, and create a corresponding function with a more readable name.  For each you want to:

1. Marshall the args from something you want to call into what the API client wants

2. Put this code in
```
    return new Promise<{responseValue}>((resolve, reject) => {
        return this.{ConnectedServiceProperty}.{theMethodName}({arguments})
            .then((response) => {
                resolve(response.body);
            })
            .catch((response) => {
                resolve(response.response);
            });
    });
```
3. Think to yourself "gee, I wish there was some way this could be accomplished with metaprogramming"

Once your interface has all the methods you need, you also need to go to `src/main/index.ts` and add your interface class.  This will make it importable

### Make some tests

Our only legacy on this earth will be the tests we wrote which are still passing.
