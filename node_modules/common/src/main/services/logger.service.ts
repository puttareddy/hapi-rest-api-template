import {injectable, inject} from "inversify";
import Winston  =  require("winston");
import * as _ from "lodash";

export let Symbols = {
    ILoggerService: Symbol("ILoggerService"),
    Winston: Symbol("Winston"),
};

export class LogCode {
    private code: number;
    private httpStatusCode: number;
    private logMessage: string;
    private responseMessage: string;

    constructor(code: number, httpStatusCode: number, logMessage: string, responseMessage: string) {
        this.code = code;
        this.httpStatusCode = httpStatusCode;
        this.logMessage = logMessage;
        this.responseMessage = responseMessage;
    }

    public getCode(): number {
        return this.code;
    }

    public getResponseMessage(): string {
        return this.responseMessage;
    }

    public getLogMessage(): string {
        return this.logMessage;
    }

    public getHttpStatusCode(): number {
        return this.httpStatusCode;
    }
}
export interface ILoggerService {
    d (message: string, requestId?: string);

    i (code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any);

    w (code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any);

    e (code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any);

    registerCode(code: number, httpStatusCode: number, logMessage: string, responseMessage: string);
    getLogCode(code: number): LogCode;
    getResponseMessage(code: number): string;
    getHttpStatusCode(code: number): number;
    setServiceName(serviceName: string);
}

@injectable()
export class LoggerService implements ILoggerService {
    private winston;
    private codes = {};
    private serviceName: string;

    public constructor(@inject(Symbols.Winston) winston: Winston.LoggerInstance) {
        this.winston = winston;
    }

    public d(message: string, requestId?: string, additionalMeta?: any) {
        this.winston.debug(message, this.createMeta(-1, "N/A", additionalMeta), (err) => {
            if (err) {
                // tslint:disable-next-line
                console.log(err);
            }
        });
    }

    public i(code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any) {
        this.winston.info(this.createLogMessage(code),
            this.createMeta(code, requestId, additionalMessage, additionalMeta), (err) => {
                if (err) {
                    // tslint:disable-next-line
                    console.log(err);
                }
            });
    }

    public w(code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any) {
        this.winston.warn(this.createLogMessage(code),
            this.createMeta(code, requestId, additionalMessage, additionalMeta), (err) => {
                if (err) {
                    // tslint:disable-next-line
                    console.log(err);
                }
            });
    }

    public e(code: number, additionalMessage?: string, requestId?: string, additionalMeta?: any) {
        this.winston.error(this.createLogMessage(code),
            this.createMeta(code, requestId, additionalMessage, additionalMeta), (err) => {
                if (err) {
                    // tslint:disable-next-line
                    console.log(err);
                }
            });
    }

    public registerCode(code: number, httpStatusCode: number, logMessage: string, responseMessage: string) {
        this.codes[code] = new LogCode(code, httpStatusCode, logMessage, responseMessage);
    }

    public getLogCode(code: number): LogCode {
        return this.codes[code];
    }

    public getResponseMessage(code: number): string {
        return this.getLogCode(code) ?
            this.getLogCode(code).getResponseMessage() :
            `No response message found for code ${code}`;
    }

    public getHttpStatusCode(code: number): number {
        return this.getLogCode(code) ?
            this.getLogCode(code).getHttpStatusCode() : 500;
    }

    public setServiceName(serviceName: string) {
        this.serviceName = serviceName;
    }

    private createMeta(code: number, requestId?: string, additionalMessage?: string, additionalMeta?: any): any {
        return _.merge({
            additionalMessage: additionalMessage || "N/A",
            code: code,
            requestId: requestId || "N/A",
            service: this.serviceName || "N/A",
        }, additionalMeta);
    }

    private createLogMessage(code: number): any {
        let c = this.codes[code];
        return c ? c.getLogMessage() : `No message found for log code ${code}`;
    }

}
