import {injectable, inject} from "inversify";
import {Request, IReply} from "hapi";
import Boom = require("boom");
import * as xml2js from "xml2js";
import {LoggerService} from "../index";

export let Symbols = {
    IHapiService: Symbol("IHapiService"),
};

export interface IHapiService {
    xmlErrorResponseHandler(req: Request, reply: IReply);
    hapiRequestHandler(req: Request, reply: IReply);
}

@injectable()
export class HapiService implements IHapiService {

    private logger: LoggerService.ILoggerService;

    constructor(
        @inject(LoggerService.Symbols.ILoggerService) logger: LoggerService.ILoggerService
    ) {
        this.logger = logger;
    }

    /*
        A big part to understand with these extensions is that if reply.continue() is called, the response is not
        replaced, and the original response is just forward onward to the next extension (if any). However, if
        reply(response) is called (with an optional code) then the response is replaced, but the chain of extensions
        ends, and no more are called. The response is returned that way to the caller.

        Unfortunately, because of this ordering, if XML error response handling is needed, the extension must be added
        BEFORE hapiRequestHandler, as both of these methods have replies that interrupt the chain of extensions. Since
        xmlErrorResponseHandler just passes on the reply if it is not XML, it should be added first in server.ext()
     */

    public hapiRequestHandler(req: Request, reply: IReply) {
        let resp: any = req.response.source;

        if (!(resp instanceof LoggerService.LogCode)) {
            return reply.continue();
        }

        let logCode: LoggerService.LogCode = resp;

        let response = Boom.create(logCode.getHttpStatusCode(), logCode.getResponseMessage());
        response.reformat();
        response.output.payload.code = logCode.getCode();
        response.output.payload.message = logCode.getResponseMessage();
        reply(response);
    }

    public xmlErrorResponseHandler(req: Request, reply: IReply) {
        let acceptKey = "accept";
        let contentTypeKey = "content-type";

        // If Accept is application/xml, then we return xml. However, if Accept is neither json or xml, we default
        // to checking the content type for whether to return xml or json
        let type = req.headers[contentTypeKey];
        if (req.headers[acceptKey] === "application/xml" || req.headers[acceptKey] === "application/json") {
            type = req.headers[acceptKey];
        }

        let responseSource = req.response.source;
        let xmlRootName = "error";
        let outputKey = "output";

        if (type === "application/xml") {
            if (responseSource instanceof LoggerService.LogCode) { // convert LogCode to XML then reply(xmlResponse)
                responseSource = responseSource as LoggerService.LogCode;

                let error = new ErrorOutputForXml();
                error.code = responseSource.getHttpStatusCode();
                error.message = responseSource.getResponseMessage();

                let builder = new xml2js.Builder({ rootName: xmlRootName });
                let xmlMessage = builder.buildObject(error);
                reply(xmlMessage).code(error.code).type("application/xml");
                return;

            } else if (req.response.isBoom === true && // not a log code, check if boom error
                (req.response[outputKey].statusCode === 404 ||
                 req.response[outputKey].statusCode === 500)) {

                // The above is done because boom status codes are located in a different place

                let error = new ErrorOutputForXml();
                error.code = req.response[outputKey].statusCode;
                error.message = req.response[outputKey].payload.error;

                let builder = new xml2js.Builder({rootName: "error"});
                let xmlMessage = builder.buildObject(error);
                reply(xmlMessage).code(req.response[outputKey].statusCode).type("application/xml");
                return;

            } else if (req.response.statusCode === 400 || req.response.statusCode === 500) { // check if 400 error

                // As above, non-boom responses have status codes in a different place

                let builder = new xml2js.Builder({ rootName: xmlRootName });
                if (responseSource instanceof Array) {

                    // If the error is a validation error, it is nested inside of an array of one.
                    // Here, we return a field also to indicate which field was problematic in joi validation

                    let error = new ErrorOutputForXml();
                    error.code = req.response.statusCode;
                    error.message = responseSource[0].message;
                    error.fields = responseSource[0].path;

                    let xmlMessage = builder.buildObject(error);
                    reply(xmlMessage).code(req.response.statusCode).type("application/xml");
                    return;

                } else {
                    let error = {
                        code: req.response.statusCode,
                        message: responseSource,
                    };

                    let xmlMessage = builder.buildObject(error);
                    reply(xmlMessage).code(req.response.statusCode).type("application/xml");
                    return;
                }
            }
        }

        return reply.continue();
    }
}

// CIBC - FXC wants to standardize error responses, even if they are different types
export class ErrorOutputForXml {
    public code: number;
    public message: string;
    public fields: string;
}
